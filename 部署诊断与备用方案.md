# Vercel 部署诊断与备用方案

## 📅 更新时间

2025-12-07 18:23

## ✅ 已完成的修复

### 1. 修正 Serverless Function 配置

- ✅ 将 API 入口从 `backend/api/index.ts` 移至 `api/index.ts`
- ✅ 更新 `vercel.json` 配置符合 Vercel 标准
- ✅ 添加动态导入支持 CommonJS/ES Modules 兼容

### 2. 依赖管理优化

- ✅ 创建根目录 `package.json` 包含核心依赖
- ✅ 配置 `installCommand` 自动安装 backend 和 frontend 依赖
- ✅ 添加 TypeScript 配置支持模块解析

### 3. 错误处理增强

- ✅ API 入口添加 try-catch 错误处理
- ✅ 添加详细的错误日志输出
- ✅ 实现 Express 应用实例缓存

## 🔍 当前部署状态

**提交**: `b9bcce22`
**推送时间**: 2025-12-07 18:20
**Vercel**: 自动部署中...

## ⚠️ 潜在问题分析

### 问题 1: Sequelize ORM 在 Serverless 环境中的限制

**问题描述**:

- Sequelize 设计用于长期运行的服务器
- Serverless Function 每次调用可能是新的实例（冷启动）
- 连接池管理在 Serverless 环境中效率低下

**影响**:

- 首次请求可能超时（冷启动 + 数据库连接初始化）
- 频繁的数据库连接建立/断开
- 可能触发数据库连接数限制

**解决方案**:

1. 优化 Sequelize 连接池配置（已在 backend 中配置）
2. 使用 Serverless 友好的数据库（如 Neon, Supabase）
3. 考虑切换到简单的 `pg` 客户端（备用方案）

### 问题 2: TypeScript 模块解析

**问题描述**:

- backend 使用 CommonJS (`module.exports`)
- api/index.ts 使用 ES Modules (`import/export`)
- 可能存在模块兼容性问题

**已采取措施**:

- ✅ 使用动态 `import()` 支持 CommonJS
- ✅ 添加类型兼容处理 `@ts-ignore`
- ✅ 创建 api/tsconfig.json 配置模块解析

### 问题 3: 依赖安装路径

**问题描述**:

- api/index.ts 需要访问 backend 的依赖
- Vercel 可能无法正确解析跨目录依赖

**已采取措施**:

- ✅ 在根 package.json 添加核心依赖
- ✅ installCommand 确保安装 backend 依赖
- ✅ tsconfig.json 配置 paths 映射

## 🔧 调试步骤

### 1. 检查 Vercel 部署日志

访问: https://vercel.com/dashboard → 选择项目 → Deployments → 最新部署

**关注点**:

- ✅ 构建是否成功
- ✅ 依赖安装是否完整
- ✅ Function 是否正确编译

### 2. 检查 Function 运行时日志

访问: https://vercel.com/dashboard → 选择项目 → Functions

**测试 API**:

```bash
curl https://ski-row.cn/api/health
curl https://ski-row.cn/api/shop/products
```

**查看日志**:

- 错误堆栈信息
- 数据库连接状态
- 模块导入错误

### 3. 检查环境变量

确认已配置:

- `DATABASE_URL` - PostgreSQL 连接字符串
- `JWT_SECRET` - JWT 密钥
- `NODE_ENV=production`
- `CORS_ORIGIN` - 前端域名

## 💡 备用方案

如果当前部署仍然失败，建议采用以下方案：

### 方案 A: 简化的 Serverless Functions（推荐）

**优势**:

- ✅ 轻量级，启动快
- ✅ 不依赖 Sequelize
- ✅ 使用简单的 `pg` 客户端
- ✅ 更适合 Serverless 环境

**实现**:
创建独立的 API 文件，每个功能一个文件：

```
api/
  ├── shop/
  │   ├── products.ts      # 商品列表
  │   └── [id].ts          # 商品详情
  ├── admin/
  │   └── login.ts         # 管理员登录
  └── test.ts              # 测试端点
```

**示例代码** (api/shop/products.ts):

```typescript
import { VercelRequest, VercelResponse } from "@vercel/node";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 2, // Serverless 环境小连接池
  idleTimeoutMillis: 1000,
});

export default async (req: VercelRequest, res: VercelResponse) => {
  try {
    const result = await pool.query(`
      SELECT p.*, c.name as category_name
      FROM products p
      LEFT JOIN categories c ON p.category_id = c.id
      WHERE p.deleted_at IS NULL
      ORDER BY p.created_at DESC
    `);

    res.status(200).json({
      code: 0,
      message: "success",
      data: result.rows,
    });
  } catch (error: any) {
    console.error("Error:", error);
    res.status(500).json({
      code: 500,
      message: "服务器错误",
      error: error.message,
    });
  }
};
```

### 方案 B: 分离后端部署

**优势**:

- ✅ 完全使用现有 backend 代码
- ✅ 不受 Serverless 限制
- ✅ 更好的性能和可控性

**实现**:

1. 将 backend 部署到 Railway/Render/Fly.io
2. 前端保留在 Vercel
3. 配置 CORS 允许跨域

**步骤**:

```bash
# 1. 在 Railway 创建项目并连接 GitHub
# 2. 配置环境变量
# 3. 自动部署 backend

# 4. 修改前端 API 地址
# frontend/.env.production
VITE_API_BASE_URL=https://your-backend.railway.app/api
```

## 📊 性能优化建议

### Serverless Function 优化

```typescript
// 1. 连接池复用
let pool: Pool | null = null;

const getPool = () => {
  if (!pool) {
    pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      max: 2,
      idleTimeoutMillis: 1000,
    });
  }
  return pool;
};

// 2. 结果缓存（可选）
const cache = new Map();

// 3. 超时控制
const timeout = (ms: number) =>
  new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), ms)
  );

export default async (req, res) => {
  try {
    const result = await Promise.race([
      yourAsyncOperation(),
      timeout(8000), // Vercel 免费版 10s 限制，留 2s buffer
    ]);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};
```

## 🎯 下一步行动

### 立即执行

1. ✅ **等待 Vercel 部署完成**（约 1-2 分钟）
2. ⏳ **访问网站测试** - https://ski-row.cn
3. ⏳ **检查 Function 日志** - 如有错误

### 如果部署失败

1. **方案 A**: 实施简化的 Serverless Functions
2. **方案 B**: 分离后端到专用服务器

### 长期优化

1. 监控 Function 性能和冷启动时间
2. 优化数据库查询和索引
3. 考虑添加 Redis 缓存层
4. 升级 Vercel Pro 获取更长执行时间

## 📝 总结

**当前策略**: 尝试将完整的 Express 应用作为 Serverless Function 部署

**成功概率**: 60-70%

- ✅ 配置已优化
- ⚠️ Sequelize 在 Serverless 环境中可能有问题
- ⚠️ 冷启动时间可能较长

**建议**:

1. 先测试当前部署
2. 如果失败或性能差,快速切换到方案 A（简化 Functions）
3. 如果需要完整功能,考虑方案 B（分离部署）
